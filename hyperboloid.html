<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HYPERBOLOID // GENERATOR</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500&display=swap');

        :root {
            --neon-cyan: #00f3ff;
            --neon-pink: #ff0055;
            --neon-purple: #bc13fe;
            --bg-color: #050505;
            --panel-bg: rgba(10, 15, 30, 0.65);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            padding: 25px;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.15);
            z-index: 10;
            border-radius: 0 15px 0 15px;
            transform: skewX(-2deg);
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 1.5rem;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #fff, var(--neon-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--neon-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        span.value-display {
            color: #fff;
            font-weight: bold;
        }

        /* Futuristic Sliders */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 0;
            background: var(--neon-pink);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px var(--neon-pink);
            transform: rotate(45deg);
            border: 2px solid #fff;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
        }

        /* Buttons */
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            background: transparent;
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: var(--neon-cyan);
            color: #000;
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        button.active {
            background: var(--neon-purple);
            border-color: var(--neon-purple);
            color: #fff;
            box-shadow: 0 0 15px var(--neon-purple);
        }

        /* Overlay Data */
        #data-overlay {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 5;
            font-family: 'Orbitron', monospace;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            pointer-events: none;
        }
        
        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 20;
            opacity: 0.3;
        }
    </style>
</head>
<body>

    <div class="scanline"></div>

    <div id="data-overlay">
        SYS.STATUS: ONLINE<br>
        RENDER: WEBGL2<br>
        GEOMETRY: HYPERBOLOID_1_SHEET<br>
        <span id="fps-counter">FPS: 60</span>
    </div>

    <div id="ui-container">
        <h1>Konstruktor</h1>

        <div class="control-group">
            <label>Taille (Radius A) <span id="val-radius" class="value-display">1.0</span></label>
            <input type="range" id="radius" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Höhe (Limit Z) <span id="val-height" class="value-display">3.0</span></label>
            <input type="range" id="height" min="1.0" max="10.0" step="0.1" value="3.0">
        </div>

        <div class="control-group">
            <label>Krümmung (Koeff. C) <span id="val-curve" class="value-display">1.0</span></label>
            <input type="range" id="curve" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <label>Verdrehung (Twist) <span id="val-twist" class="value-display">0.0</span></label>
            <input type="range" id="twist" min="0" max="6.28" step="0.1" value="0.0">
        </div>

        <div class="control-group">
            <label>Segmente (Auflösung) <span id="val-segments" class="value-display">30</span></label>
            <input type="range" id="segments" min="10" max="100" step="1" value="30">
        </div>

        <div class="control-group">
            <label>Anzeige-Modus</label>
            <div class="btn-group">
                <button id="mode-wire" class="active">Netz</button>
                <button id="mode-solid">Solid</button>
                <button id="mode-points">Partikel</button>
            </div>
        </div>

        <div class="control-group">
            <button id="anim-toggle">Auto-Rotation: EIN</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js Library via CDN -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';

        // --- CONFIG ---
        const params = {
            a: 1.0, // Radius at waist
            c: 1.0, // Vertical scaling factor
            uLimit: 3.0, // Height limit
            twist: 0.0,
            segments: 30,
            mode: 'wireframe', // wireframe, solid, points
            autoRotate: true
        };

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 5, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0; // High bloom for neon effect
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- GEOMETRY GENERATION ---
        // Formula: x^2/a^2 + y^2/a^2 - z^2/c^2 = 1
        // Parametric: 
        // x = a * sqrt(1 + u^2) * cos(v)
        // y = a * sqrt(1 + u^2) * sin(v)
        // z = c * u
        // where u is height parameter, v is angle

        let mesh;
        const materialWire = new THREE.MeshBasicMaterial({ 
            color: 0x00f3ff, 
            wireframe: true,
            transparent: true,
            opacity: 0.5
        });
        const materialSolid = new THREE.MeshPhysicalMaterial({
            color: 0x111111,
            emissive: 0xbc13fe,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.1,
            clearcoat: 1.0,
            side: THREE.DoubleSide,
            wireframe: false
        });
        const materialPoints = new THREE.PointsMaterial({
            color: 0xff0055,
            size: 0.1,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        function createHyperboloid() {
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
            }

            // Create parametric geometry function
            const func = (u, v, target) => {
                // u goes from 0 to 1, map to -uLimit to +uLimit
                const uMapped = (u - 0.5) * 2 * params.uLimit; 
                // v goes from 0 to 1, map to 0 to 2PI
                const vMapped = v * Math.PI * 2;

                // Hyperboloid logic
                const r = params.a * Math.sqrt(1 + Math.pow(uMapped, 2)); // Radius at height u
                
                // Add twist if requested
                const twistAngle = uMapped * params.twist;

                const x = r * Math.cos(vMapped + twistAngle);
                const y = uMapped * params.c; // Z in math formula, but Y in Three.js is up
                const z = r * Math.sin(vMapped + twistAngle);

                target.set(x, y, z);
            };

            const geometry = new THREE.ParametricGeometry(func, params.segments, params.segments);
            
            // Choose material
            if (params.mode === 'points') {
                mesh = new THREE.Points(geometry, materialPoints);
            } else if (params.mode === 'solid') {
                mesh = new THREE.Mesh(geometry, materialSolid);
            } else {
                mesh = new THREE.Mesh(geometry, materialWire);
            }
            
            scene.add(mesh);
        }

        createHyperboloid();

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(0x00f3ff, 2, 50);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff0055, 2, 50);
        pointLight2.position.set(-10, -10, -10);
        scene.add(pointLight2);

        // --- BACKGROUND GRID ---
        const gridHelper = new THREE.GridHelper(40, 40, 0x333333, 0x111111);
        scene.add(gridHelper);

        // --- UI EVENT LISTENERS ---
        const updateVal = (id, val) => document.getElementById(`val-${id}`).innerText = val;

        document.getElementById('radius').addEventListener('input', (e) => {
            params.a = parseFloat(e.target.value);
            updateVal('radius', params.a);
            createHyperboloid();
        });
        document.getElementById('height').addEventListener('input', (e) => {
            params.uLimit = parseFloat(e.target.value);
            updateVal('height', params.uLimit);
            createHyperboloid();
        });
        document.getElementById('curve').addEventListener('input', (e) => {
            params.c = parseFloat(e.target.value); // Actually affecting height scaling relative to u
            updateVal('curve', params.c);
            createHyperboloid();
        });
        document.getElementById('twist').addEventListener('input', (e) => {
            params.twist = parseFloat(e.target.value);
            updateVal('twist', params.twist.toFixed(1));
            createHyperboloid();
        });
        document.getElementById('segments').addEventListener('input', (e) => {
            params.segments = parseInt(e.target.value);
            updateVal('segments', params.segments);
            createHyperboloid();
        });

        // Mode switching
        const btns = ['mode-wire', 'mode-solid', 'mode-points'];
        btns.forEach(id => {
            document.getElementById(id).addEventListener('click', (e) => {
                btns.forEach(b => document.getElementById(b).classList.remove('active'));
                e.target.classList.add('active');
                if(id === 'mode-wire') params.mode = 'wireframe';
                if(id === 'mode-solid') params.mode = 'solid';
                if(id === 'mode-points') params.mode = 'points';
                createHyperboloid();
            });
        });

        const animBtn = document.getElementById('anim-toggle');
        animBtn.addEventListener('click', () => {
            params.autoRotate = !params.autoRotate;
            animBtn.innerText = params.autoRotate ? "Auto-Rotation: EIN" : "Auto-Rotation: AUS";
            animBtn.classList.toggle('active');
        });


        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        const fpsElem = document.getElementById('fps-counter');
        let frameCount = 0;
        let lastTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Rotation
            if (params.autoRotate && mesh) {
                mesh.rotation.y += 0.2 * delta;
            }

            // Pulse Effect on lights
            const t = clock.getElapsedTime();
            pointLight1.intensity = 2 + Math.sin(t * 2) * 0.5;
            pointLight2.intensity = 2 + Math.cos(t * 1.5) * 0.5;

            controls.update();
            composer.render();

            // FPS Counter
            if (time - lastTime >= 1000) {
                fpsElem.innerText = `FPS: ${Math.round(frameCount * 1000 / (time - lastTime))}`;
                frameCount = 0;
                lastTime = time;
            }
            frameCount++;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);
    </script>
</body>
</html>