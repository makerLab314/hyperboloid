<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>HYPERBOLOID // GENERATOR</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500&display=swap');

        :root{
            --neon-cyan:#00f3ff;
            --neon-pink:#ff0055;
            --neon-purple:#bc13fe;
            --neon-green:#39ff14;
            --neon-orange:#ff6b35;
            --bg-color:#050505;
            --panel-bg:rgba(10,15,30,0.85);
        }

        html,body{height:100%;margin:0;background:radial-gradient(circle at center,#1a1a2e 0%,#000 100%);font-family:'Rajdhani',sans-serif;color:#fff;overflow:hidden}
        #canvas-container{position:absolute;inset:0;z-index:1}
        .scanline{position:absolute;inset:0;pointer-events:none;background:
            linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size:100% 4px;opacity:0.25;z-index:20;animation:scan 8s linear infinite}
        @keyframes scan{0%{background-position:0 0}100%{background-position:0 100px}}
        
        #ui-container{
            position:absolute;top:20px;right:20px;width:380px;max-height:calc(100vh - 40px);
            padding:22px;background:var(--panel-bg);
            backdrop-filter:blur(16px);border:1px solid rgba(255,255,255,0.1);border-left:4px solid var(--neon-cyan);
            box-shadow:0 0 30px rgba(0,243,255,0.15), inset 0 0 20px rgba(0,243,255,0.03);
            z-index:10;border-radius:0 20px 0 20px;transform:skewX(-1deg);
            overflow-y:auto;overflow-x:hidden;
        }
        #ui-container::-webkit-scrollbar{width:8px}
        #ui-container::-webkit-scrollbar-track{background:rgba(255,255,255,0.05)}
        #ui-container::-webkit-scrollbar-thumb{background:var(--neon-cyan);border-radius:4px}
        
        h1{font-family:'Orbitron',sans-serif;font-weight:900;font-size:1.5rem;margin:0 0 20px;background:linear-gradient(90deg,#fff,var(--neon-cyan),var(--neon-purple));
            -webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:2px;text-transform:uppercase;animation:pulse 3s ease-in-out infinite}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.8}}
        
        h2{font-family:'Orbitron',sans-serif;font-weight:700;font-size:1rem;margin:20px 0 12px;color:var(--neon-cyan);
            text-transform:uppercase;letter-spacing:1.5px;border-bottom:1px solid rgba(0,243,255,0.3);padding-bottom:8px;cursor:pointer}
        h2:hover{color:var(--neon-purple)}
        h2::before{content:'▼ ';font-size:0.8rem;margin-right:8px;transition:transform 0.3s}
        h2.collapsed::before{transform:rotate(-90deg);display:inline-block}
        
        .section{margin-bottom:20px;overflow:hidden;transition:max-height 0.3s ease-out,opacity 0.3s}
        .section.collapsed{max-height:0!important;opacity:0;margin:0}
        
        .control-group{margin-bottom:16px;padding:8px;border-radius:8px;transition:background 0.2s}
        .control-group:hover{background:rgba(0,243,255,0.05)}
        
        label{display:flex;justify-content:space-between;font-size:0.85rem;margin-bottom:10px;color:var(--neon-cyan);text-transform:uppercase;letter-spacing:1px}
        span.value-display{color:#fff;font-weight:700;font-family:'Orbitron',monospace;padding:2px 8px;background:rgba(0,243,255,0.1);border-radius:4px}
        
        input[type=range]{-webkit-appearance:none;width:100%;background:transparent;cursor:pointer}
        input[type=range]::-webkit-slider-runnable-track{height:6px;background:rgba(255,255,255,0.1);border:1px solid rgba(0,243,255,0.3);border-radius:3px;box-shadow:inset 0 0 5px rgba(0,0,0,0.5)}
        input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;height:18px;width:18px;background:linear-gradient(135deg,var(--neon-pink),var(--neon-purple));
            box-shadow:0 0 15px var(--neon-pink),0 0 5px #fff;transform:rotate(45deg);border:2px solid #fff;margin-top:-6px;transition:all 0.2s}
        input[type=range]::-webkit-slider-thumb:hover{transform:rotate(45deg) scale(1.2);box-shadow:0 0 20px var(--neon-pink),0 0 10px #fff}
        
        input[type=color]{-webkit-appearance:none;width:100%;height:40px;border:2px solid var(--neon-cyan);border-radius:8px;background:transparent;cursor:pointer;
            box-shadow:0 0 10px rgba(0,243,255,0.3)}
        input[type=color]::-webkit-color-swatch-wrapper{padding:4px}
        input[type=color]::-webkit-color-swatch{border:none;border-radius:4px;box-shadow:inset 0 0 10px rgba(0,0,0,0.5)}
        
        .btn-group{display:flex;gap:8px;flex-wrap:wrap}
        button{flex:1;min-width:calc(33% - 6px);background:transparent;border:1px solid var(--neon-cyan);color:var(--neon-cyan);padding:12px 8px;
            font-family:'Orbitron';cursor:pointer;text-transform:uppercase;letter-spacing:1px;font-size:0.75rem;border-radius:8px;
            transition:all 0.3s;position:relative;overflow:hidden}
        button::before{content:'';position:absolute;top:50%;left:50%;width:0;height:0;background:var(--neon-cyan);
            border-radius:50%;transform:translate(-50%,-50%);transition:width 0.6s,height 0.6s;z-index:-1}
        button:hover::before{width:300px;height:300px}
        button:hover{color:#000;box-shadow:0 0 20px var(--neon-cyan);transform:translateY(-2px)}
        button.active{background:var(--neon-purple);border-color:var(--neon-purple);color:#fff;box-shadow:0 0 20px var(--neon-purple)}
        button.full-width{width:100%;margin-top:8px}
        
        #data-overlay{position:absolute;left:30px;bottom:30px;color:rgba(255,255,255,0.7);font-family:'Orbitron',monospace;font-size:0.85rem;z-index:5;pointer-events:none;
            text-shadow:0 0 10px rgba(0,243,255,0.5)}
        
        .preset-btn{font-size:0.7rem;padding:8px;margin:4px}
        
        #particles-bg{position:absolute;inset:0;z-index:0;pointer-events:none}
    </style>
</head>
<body>
    <canvas id="particles-bg"></canvas>
    <div class="scanline"></div>

    <div id="data-overlay">
        SYS.STATUS: ONLINE<br>
        RENDER: WEBGL<br>
        GEOMETRY: HYPERBOLOID_1_SHEET<br>
        <span id="fps-counter">FPS: --</span><br>
        <span id="vertex-counter">VERTICES: --</span>
    </div>

    <div id="ui-container">
        <h1>⚡ Hyperboloid ⚡</h1>

        <!-- GEOMETRY SECTION -->
        <h2 id="h-geometry">Geometrie</h2>
        <div class="section" id="s-geometry">
            <div class="control-group">
                <label>Taille (Radius A) <span id="val-radius" class="value-display">1.0</span></label>
                <input type="range" id="radius" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Höhe (Limit Z) <span id="val-height" class="value-display">3.0</span></label>
                <input type="range" id="height" min="1.0" max="10.0" step="0.1" value="3.0">
            </div>

            <div class="control-group">
                <label>Krümmung (Koeff. C) <span id="val-curve" class="value-display">1.0</span></label>
                <input type="range" id="curve" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>Verdrehung (Twist) <span id="val-twist" class="value-display">0.0</span></label>
                <input type="range" id="twist" min="-6.28" max="6.28" step="0.01" value="0.0">
            </div>

            <div class="control-group">
                <label>Segmente (Auflösung) <span id="val-segments" class="value-display">40</span></label>
                <input type="range" id="segments" min="8" max="140" step="1" value="40">
            </div>

            <div class="control-group">
                <label>Dicke (Thickness) <span id="val-thickness" class="value-display">1.0</span></label>
                <input type="range" id="thickness" min="0.1" max="2.0" step="0.05" value="1.0">
            </div>
        </div>

        <!-- TRANSFORM SECTION -->
        <h2 id="h-transform">Transformation</h2>
        <div class="section" id="s-transform">
            <div class="control-group">
                <label>Rotation X <span id="val-rotx" class="value-display">0.0</span></label>
                <input type="range" id="rotx" min="0" max="6.28" step="0.01" value="0.0">
            </div>

            <div class="control-group">
                <label>Rotation Y <span id="val-roty" class="value-display">0.0</span></label>
                <input type="range" id="roty" min="0" max="6.28" step="0.01" value="0.0">
            </div>

            <div class="control-group">
                <label>Rotation Z <span id="val-rotz" class="value-display">0.0</span></label>
                <input type="range" id="rotz" min="0" max="6.28" step="0.01" value="0.0">
            </div>

            <div class="control-group">
                <label>Skalierung <span id="val-scale" class="value-display">1.0</span></label>
                <input type="range" id="scale" min="0.2" max="3.0" step="0.1" value="1.0">
            </div>
        </div>

        <!-- MATERIAL SECTION -->
        <h2 id="h-material">Material & Farben</h2>
        <div class="section" id="s-material">
            <div class="control-group">
                <label>Primärfarbe</label>
                <input type="color" id="color-primary" value="#00f3ff">
            </div>

            <div class="control-group">
                <label>Sekundärfarbe</label>
                <input type="color" id="color-secondary" value="#bc13fe">
            </div>

            <div class="control-group">
                <label>Akzentfarbe</label>
                <input type="color" id="color-accent" value="#ff0055">
            </div>

            <div class="control-group">
                <label>Metallic <span id="val-metalness" class="value-display">0.9</span></label>
                <input type="range" id="metalness" min="0" max="1" step="0.05" value="0.9">
            </div>

            <div class="control-group">
                <label>Roughness <span id="val-roughness" class="value-display">0.12</span></label>
                <input type="range" id="roughness" min="0" max="1" step="0.01" value="0.12">
            </div>

            <div class="control-group">
                <label>Emissive <span id="val-emissive" class="value-display">0.25</span></label>
                <input type="range" id="emissive" min="0" max="2" step="0.05" value="0.25">
            </div>

            <div class="control-group">
                <label>Opacity <span id="val-opacity" class="value-display">1.0</span></label>
                <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="1.0">
            </div>
        </div>

        <!-- ANIMATION SECTION -->
        <h2 id="h-animation">Animation</h2>
        <div class="section" id="s-animation">
            <div class="control-group">
                <label>Geschwindigkeit <span id="val-animspeed" class="value-display">1.0</span></label>
                <input type="range" id="animspeed" min="0" max="5" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Puls-Rate <span id="val-pulse" class="value-display">0.5</span></label>
                <input type="range" id="pulse" min="0" max="3" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <button id="anim-toggle" class="active full-width">Auto-Rotation: EIN</button>
            </div>
        </div>

        <!-- DISPLAY SECTION -->
        <h2 id="h-display">Anzeige</h2>
        <div class="section" id="s-display">
            <div class="control-group">
                <label>Anzeige-Modus</label>
                <div class="btn-group">
                    <button id="mode-wire" class="active">Netz</button>
                    <button id="mode-solid">Solid</button>
                    <button id="mode-points">Partikel</button>
                    <button id="mode-lines">Linien</button>
                </div>
            </div>

            <div class="control-group" id="physics-control" style="display:none;">
                <label>Physik-Modus</label>
                <div class="btn-group">
                    <button id="physics-toggle">Gummiband: AUS</button>
                </div>
                <div style="margin-top:8px;">
                    <label>Reiß-Schwelle <span id="val-tear" class="value-display">2.0</span></label>
                    <input type="range" id="tear-threshold" min="1.1" max="5.0" step="0.1" value="2.0">
                </div>
            </div>

            <div class="control-group">
                <label>Grid</label>
                <div class="btn-group">
                    <button id="grid-toggle" class="active">EIN</button>
                    <button id="fog-toggle" class="active">Nebel</button>
                </div>
            </div>
        </div>

        <!-- PRESETS SECTION -->
        <h2 id="h-presets">Presets</h2>
        <div class="section" id="s-presets">
            <div class="btn-group">
                <button class="preset-btn" data-preset="default">Default</button>
                <button class="preset-btn" data-preset="twisted">Twisted</button>
                <button class="preset-btn" data-preset="thin">Dünn</button>
                <button class="preset-btn" data-preset="wide">Breit</button>
                <button class="preset-btn" data-preset="crystal">Kristall</button>
                <button class="preset-btn" data-preset="neon">Neon</button>
            </div>
            <button id="reset-btn" class="full-width">Reset All</button>
            <button id="screenshot-btn" class="full-width">Screenshot</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Particles Background
        const particleCanvas = document.getElementById('particles-bg');
        const pctx = particleCanvas.getContext('2d');
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;
        
        const particles = [];
        for(let i = 0; i < 100; i++){
            particles.push({
                x: Math.random() * particleCanvas.width,
                y: Math.random() * particleCanvas.height,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: Math.random() * 2 + 1
            });
        }
        
        function animateParticles(){
            pctx.fillStyle = 'rgba(0,0,0,0.05)';
            pctx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if(p.x < 0 || p.x > particleCanvas.width) p.vx *= -1;
                if(p.y < 0 || p.y > particleCanvas.height) p.vy *= -1;
                pctx.fillStyle = `rgba(0,243,255,${Math.random() * 0.5 + 0.3})`;
                pctx.beginPath();
                pctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                pctx.fill();
            });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        // Parameter
        const params = {
            a: 1.0,
            c: 1.0,
            uLimit: 3.0,
            twist: 0.0,
            segments: 40,
            thickness: 1.0,
            mode: 'wireframe',
            autoRotate: true,
            rotX: 0.0,
            rotY: 0.0,
            rotZ: 0.0,
            scale: 1.0,
            colorPrimary: 0x00f3ff,
            colorSecondary: 0xbc13fe,
            colorAccent: 0xff0055,
            metalness: 0.9,
            roughness: 0.12,
            emissive: 0.25,
            opacity: 1.0,
            animSpeed: 1.0,
            pulseRate: 0.5,
            showGrid: true,
            showFog: true,
            physicsEnabled: false,
            tearThreshold: 2.0
        };

        // Physics state for rubber band simulation
        let physicsLines = [];
        let tornLines = new Set();

        // Szene, Kamera, Renderer
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 5, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.07;

        // Materialien
        const materialWire = new THREE.MeshBasicMaterial({
            color: 0x00f3ff,
            wireframe: true,
            transparent: true,
            opacity: 0.6
        });
        const materialSolid = new THREE.MeshPhysicalMaterial({
            color: 0x0b0b0b,
            emissive: 0xbc13fe,
            emissiveIntensity: 0.25,
            metalness: 0.9,
            roughness: 0.12,
            clearcoat: 1.0,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 1.0
        });
        const materialPoints = new THREE.PointsMaterial({
            color: 0xff0055,
            size: 0.08,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });

        let mesh = null;

        // Funktion: eigene Parametrische Geometrie als BufferGeometry
        function buildHyperboloidGeometry(a, c, uLimit, segments, twist, thickness) {
            const seg = Math.max(3, Math.floor(segments));
            const rows = seg + 1;
            const cols = seg + 1;
            const vertexCount = rows * cols;
            const positions = new Float32Array(vertexCount * 3);
            const uvs = new Float32Array(vertexCount * 2);
            let ptr = 0;
            let uPtr = 0;

            for (let i = 0; i <= seg; i++) {
                const iu = i / seg;
                const u = -uLimit + iu * (2 * uLimit);

                for (let j = 0; j <= seg; j++) {
                    const jv = j / seg;
                    const v = jv * Math.PI * 2;

                    const r = a * Math.sqrt(1 + u * u) * thickness;
                    const twistAngle = u * twist;

                    const x = r * Math.cos(v + twistAngle);
                    const y = u * c;
                    const z = r * Math.sin(v + twistAngle);

                    positions[ptr++] = x;
                    positions[ptr++] = y;
                    positions[ptr++] = z;

                    uvs[uPtr++] = jv;
                    uvs[uPtr++] = iu;
                }
            }

            const indices = new Uint32Array(seg * seg * 6);
            let ip = 0;
            for (let i = 0; i < seg; i++) {
                for (let j = 0; j < seg; j++) {
                    const aIdx = i * (seg + 1) + j;
                    const bIdx = aIdx + 1;
                    const cIdx = (i + 1) * (seg + 1) + j;
                    const dIdx = cIdx + 1;

                    indices[ip++] = aIdx;
                    indices[ip++] = cIdx;
                    indices[ip++] = bIdx;

                    indices[ip++] = bIdx;
                    indices[ip++] = cIdx;
                    indices[ip++] = dIdx;
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), Math.hypot(a * Math.sqrt(1 + uLimit * uLimit), uLimit * c) * 1.2);

            return geometry;
        }

        // Build lines data - straight lines connecting top and bottom of the hyperboloid
        function buildLinesData(a, c, uLimit, numLines, twist, thickness) {
            const positions = [];
            const lineRestLengths = [];
            
            // Calculate rest length (straight vertical line when twist = 0)
            const topY = uLimit * c;
            const bottomY = -uLimit * c;
            const restLength = topY - bottomY;
            
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                
                // Top point (u = uLimit)
                const topR = a * Math.sqrt(1 + uLimit * uLimit) * thickness;
                const topTwist = uLimit * twist;
                const topX = topR * Math.cos(angle + topTwist);
                const topZ = topR * Math.sin(angle + topTwist);
                
                // Bottom point (u = -uLimit)
                const bottomR = a * Math.sqrt(1 + uLimit * uLimit) * thickness;
                const bottomTwist = -uLimit * twist;
                const bottomX = bottomR * Math.cos(angle + bottomTwist);
                const bottomZ = bottomR * Math.sin(angle + bottomTwist);
                
                positions.push(topX, topY, topZ);
                positions.push(bottomX, bottomY, bottomZ);
                
                // Calculate current length for physics
                const dx = topX - bottomX;
                const dy = topY - bottomY;
                const dz = topZ - bottomZ;
                const currentLength = Math.sqrt(dx*dx + dy*dy + dz*dz);
                lineRestLengths.push({ index: i, restLength, currentLength });
            }
            
            return { positions, lineRestLengths, numLines };
        }

        // Material for lines
        const materialLine = new THREE.LineBasicMaterial({
            color: 0x00f3ff,
            transparent: true,
            opacity: 0.9,
            linewidth: 2
        });

        function createHyperboloid() {
            if (mesh) {
                scene.remove(mesh);
                // Handle cleanup for Groups (lines mode)
                if (mesh.isGroup) {
                    mesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                } else {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) mesh.material.forEach(m => m.dispose());
                        else mesh.material.dispose();
                    }
                }
                mesh = null;
            }

            // Handle lines mode separately
            if (params.mode === 'lines') {
                const numLines = Math.max(8, Math.floor(params.segments));
                const linesData = buildLinesData(params.a, params.c, params.uLimit, numLines, params.twist, params.thickness);
                document.getElementById('vertex-counter').innerText = `LINES: ${numLines}`;
                
                // Reset torn lines when geometry changes (unless physics is active and we want to preserve state)
                if (!params.physicsEnabled) {
                    tornLines.clear();
                }
                
                // Create individual line segments with physics support
                const group = new THREE.Group();
                const positions = linesData.positions;
                
                for (let i = 0; i < numLines; i++) {
                    // Skip torn lines
                    if (tornLines.has(i)) continue;
                    
                    const linePositions = new Float32Array(6);
                    linePositions[0] = positions[i * 6];
                    linePositions[1] = positions[i * 6 + 1];
                    linePositions[2] = positions[i * 6 + 2];
                    linePositions[3] = positions[i * 6 + 3];
                    linePositions[4] = positions[i * 6 + 4];
                    linePositions[5] = positions[i * 6 + 5];
                    
                    const lineGeom = new THREE.BufferGeometry();
                    lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
                    
                    // Color based on stretch if physics enabled
                    const mat = materialLine.clone();
                    mat.color.setHex(params.colorPrimary);
                    mat.opacity = params.opacity;
                    
                    if (params.physicsEnabled && linesData.lineRestLengths[i]) {
                        const { restLength, currentLength } = linesData.lineRestLengths[i];
                        const stretchRatio = currentLength / restLength;
                        
                        // Check if line should tear
                        if (stretchRatio > params.tearThreshold) {
                            tornLines.add(i);
                            lineGeom.dispose();
                            mat.dispose();
                            continue;
                        }
                        
                        // Color gradient: green (relaxed) -> yellow -> red (stretched)
                        if (stretchRatio <= 1.0) {
                            mat.color.setHex(0x00ff00); // Green - compressed
                        } else if (stretchRatio < 1.5) {
                            // Interpolate green to yellow
                            const t = (stretchRatio - 1.0) / 0.5;
                            mat.color.setRGB(t, 1, 0);
                        } else if (stretchRatio < params.tearThreshold) {
                            // Interpolate yellow to red
                            const denominator = params.tearThreshold - 1.5;
                            const t = denominator > 0.001 ? (stretchRatio - 1.5) / denominator : 1;
                            mat.color.setRGB(1, 1 - t, 0);
                        }
                    }
                    
                    const line = new THREE.Line(lineGeom, mat);
                    line.userData = { lineIndex: i };
                    group.add(line);
                }
                
                mesh = group;
                mesh.rotation.set(params.rotX, params.rotY, params.rotZ);
                mesh.scale.setScalar(params.scale);
                scene.add(mesh);
                return;
            }

            const geom = buildHyperboloidGeometry(params.a, params.c, params.uLimit, params.segments, params.twist, params.thickness);
            document.getElementById('vertex-counter').innerText = `VERTICES: ${geom.attributes.position.count}`;

            if (params.mode === 'points') {
                const mat = materialPoints.clone();
                mat.color.setHex(params.colorAccent);
                mat.opacity = params.opacity;
                mesh = new THREE.Points(geom, mat);
            } else {
                if (params.mode === 'solid') {
                    const mat = materialSolid.clone();
                    mat.emissive.setHex(params.colorSecondary);
                    mat.emissiveIntensity = params.emissive;
                    mat.metalness = params.metalness;
                    mat.roughness = params.roughness;
                    mat.opacity = params.opacity;
                    mat.transparent = params.opacity < 1.0;
                    mesh = new THREE.Mesh(geom, mat);
                } else {
                    const mat = materialWire.clone();
                    mat.color.setHex(params.colorPrimary);
                    mat.wireframe = true;
                    mat.opacity = params.opacity;
                    mesh = new THREE.Mesh(geom, mat);
                }
            }
            
            mesh.rotation.set(params.rotX, params.rotY, params.rotZ);
            mesh.scale.setScalar(params.scale);
            scene.add(mesh);
        }

        // Lichter & Hilfen
        const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00f3ff, 2.0, 100);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff0055, 2.0, 100);
        pointLight2.position.set(-10, -10, -10);
        scene.add(pointLight2);

        const grid = new THREE.GridHelper(60, 60, 0x222222, 0x111111);
        scene.add(grid);

        createHyperboloid();

        // UI Bindings
        const updateVal = (id, val) => {
            const elem = document.getElementById(`val-${id}`);
            if(elem) elem.innerText = val;
        };

        const toHexColor = (num) => '#' + num.toString(16).padStart(6,'0').toLowerCase();
        
        // Sync all UI displays with current params
        const syncAllDisplays = () => {
            updateVal('radius', params.a.toFixed(2));
            updateVal('height', params.uLimit.toFixed(2));
            updateVal('curve', params.c.toFixed(2));
            updateVal('twist', params.twist.toFixed(2));
            updateVal('segments', params.segments);
            updateVal('thickness', params.thickness.toFixed(2));
            updateVal('rotx', params.rotX.toFixed(2));
            updateVal('roty', params.rotY.toFixed(2));
            updateVal('rotz', params.rotZ.toFixed(2));
            updateVal('scale', params.scale.toFixed(2));
            updateVal('metalness', params.metalness.toFixed(2));
            updateVal('roughness', params.roughness.toFixed(2));
            updateVal('emissive', params.emissive.toFixed(2));
            updateVal('opacity', params.opacity.toFixed(2));
            updateVal('animspeed', params.animSpeed.toFixed(1));
            updateVal('pulse', params.pulseRate.toFixed(1));
        };

        // Geometry controls
        document.getElementById('radius').addEventListener('input', (e) => {
            params.a = parseFloat(e.target.value);
            updateVal('radius', params.a.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('height').addEventListener('input', (e) => {
            params.uLimit = parseFloat(e.target.value);
            updateVal('height', params.uLimit.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('curve').addEventListener('input', (e) => {
            params.c = parseFloat(e.target.value);
            updateVal('curve', params.c.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('twist').addEventListener('input', (e) => {
            params.twist = parseFloat(e.target.value);
            updateVal('twist', params.twist.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('segments').addEventListener('input', (e) => {
            params.segments = Math.max(3, parseInt(e.target.value));
            updateVal('segments', params.segments);
            createHyperboloid();
        });
        document.getElementById('thickness').addEventListener('input', (e) => {
            params.thickness = parseFloat(e.target.value);
            updateVal('thickness', params.thickness.toFixed(2));
            createHyperboloid();
        });

        // Transform controls
        document.getElementById('rotx').addEventListener('input', (e) => {
            params.rotX = parseFloat(e.target.value);
            updateVal('rotx', params.rotX.toFixed(2));
            if(mesh) mesh.rotation.x = params.rotX;
        });
        document.getElementById('roty').addEventListener('input', (e) => {
            params.rotY = parseFloat(e.target.value);
            updateVal('roty', params.rotY.toFixed(2));
            if(mesh) mesh.rotation.y = params.rotY;
        });
        document.getElementById('rotz').addEventListener('input', (e) => {
            params.rotZ = parseFloat(e.target.value);
            updateVal('rotz', params.rotZ.toFixed(2));
            if(mesh) mesh.rotation.z = params.rotZ;
        });
        document.getElementById('scale').addEventListener('input', (e) => {
            params.scale = parseFloat(e.target.value);
            updateVal('scale', params.scale.toFixed(2));
            if(mesh) mesh.scale.setScalar(params.scale);
        });

        // Material controls
        document.getElementById('color-primary').addEventListener('input', (e) => {
            params.colorPrimary = parseInt(e.target.value.replace('#',''),16);
            createHyperboloid();
        });
        document.getElementById('color-secondary').addEventListener('input', (e) => {
            params.colorSecondary = parseInt(e.target.value.replace('#',''),16);
            createHyperboloid();
        });
        document.getElementById('color-accent').addEventListener('input', (e) => {
            params.colorAccent = parseInt(e.target.value.replace('#',''),16);
            createHyperboloid();
        });
        document.getElementById('metalness').addEventListener('input', (e) => {
            params.metalness = parseFloat(e.target.value);
            updateVal('metalness', params.metalness.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('roughness').addEventListener('input', (e) => {
            params.roughness = parseFloat(e.target.value);
            updateVal('roughness', params.roughness.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('emissive').addEventListener('input', (e) => {
            params.emissive = parseFloat(e.target.value);
            updateVal('emissive', params.emissive.toFixed(2));
            createHyperboloid();
        });
        document.getElementById('opacity').addEventListener('input', (e) => {
            params.opacity = parseFloat(e.target.value);
            updateVal('opacity', params.opacity.toFixed(2));
            createHyperboloid();
        });

        // Animation controls
        document.getElementById('animspeed').addEventListener('input', (e) => {
            params.animSpeed = parseFloat(e.target.value);
            updateVal('animspeed', params.animSpeed.toFixed(1));
        });
        document.getElementById('pulse').addEventListener('input', (e) => {
            params.pulseRate = parseFloat(e.target.value);
            updateVal('pulse', params.pulseRate.toFixed(1));
        });

        // Display mode buttons
        const btns = ['mode-wire', 'mode-solid', 'mode-points', 'mode-lines'];
        btns.forEach(id => {
            document.getElementById(id).addEventListener('click', (ev) => {
                btns.forEach(b => document.getElementById(b).classList.remove('active'));
                ev.target.classList.add('active');
                if (id === 'mode-wire') params.mode = 'wireframe';
                if (id === 'mode-solid') params.mode = 'solid';
                if (id === 'mode-points') params.mode = 'points';
                if (id === 'mode-lines') params.mode = 'lines';
                
                // Show/hide physics control based on mode
                const physicsControl = document.getElementById('physics-control');
                physicsControl.style.display = params.mode === 'lines' ? 'block' : 'none';
                
                createHyperboloid();
            });
        });

        // Physics toggle
        const physicsBtn = document.getElementById('physics-toggle');
        physicsBtn.addEventListener('click', () => {
            params.physicsEnabled = !params.physicsEnabled;
            physicsBtn.innerText = params.physicsEnabled ? "Gummiband: EIN" : "Gummiband: AUS";
            physicsBtn.classList.toggle('active');
            if (!params.physicsEnabled) {
                tornLines.clear(); // Reset torn lines when disabling physics
            }
            createHyperboloid();
        });

        // Tear threshold
        document.getElementById('tear-threshold').addEventListener('input', (e) => {
            params.tearThreshold = parseFloat(e.target.value);
            document.getElementById('val-tear').innerText = params.tearThreshold.toFixed(1);
            tornLines.clear(); // Reset torn lines when threshold changes
            createHyperboloid();
        });

        const animBtn = document.getElementById('anim-toggle');
        animBtn.addEventListener('click', () => {
            params.autoRotate = !params.autoRotate;
            animBtn.innerText = params.autoRotate ? "Auto-Rotation: EIN" : "Auto-Rotation: AUS";
            animBtn.classList.toggle('active');
        });

        document.getElementById('grid-toggle').addEventListener('click', (e) => {
            params.showGrid = !params.showGrid;
            grid.visible = params.showGrid;
            e.target.classList.toggle('active');
        });

        document.getElementById('fog-toggle').addEventListener('click', (e) => {
            params.showFog = !params.showFog;
            scene.fog = params.showFog ? new THREE.FogExp2(0x000000, 0.02) : null;
            e.target.classList.toggle('active');
        });

        // Collapsible sections
        document.querySelectorAll('#ui-container h2').forEach(h2 => {
            h2.addEventListener('click', () => {
                const sectionId = h2.id.replace('h-', 's-');
                const section = document.getElementById(sectionId);
                if(section){
                    const isCollapsed = section.classList.contains('collapsed');
                    if(isCollapsed){
                        section.style.maxHeight = section.scrollHeight + 'px';
                        section.classList.remove('collapsed');
                        h2.classList.remove('collapsed');
                    } else {
                        section.style.maxHeight = '0';
                        section.classList.add('collapsed');
                        h2.classList.add('collapsed');
                    }
                }
            });
        });

        // Initialize section heights
        document.querySelectorAll('.section').forEach(section => {
            section.style.maxHeight = section.scrollHeight + 'px';
        });

        // Presets
        const presets = {
            default: {a:1,c:1,uLimit:3,twist:0,segments:40,thickness:1,rotX:0,rotY:0,rotZ:0,scale:1,colorPrimary:0x00f3ff,colorSecondary:0xbc13fe,colorAccent:0xff0055,metalness:0.9,roughness:0.12,emissive:0.25,opacity:1,mode:'wireframe'},
            twisted: {a:1.5,c:1.2,uLimit:4,twist:3.14,segments:60,thickness:0.8,rotX:0,rotY:0,rotZ:0,scale:1,colorPrimary:0xff0055,colorSecondary:0x00f3ff,colorAccent:0xbc13fe,metalness:0.7,roughness:0.2,emissive:0.4,opacity:0.9,mode:'solid'},
            thin: {a:0.5,c:2,uLimit:6,twist:0,segments:80,thickness:0.3,rotX:0,rotY:0,rotZ:0,scale:1,colorPrimary:0x39ff14,colorSecondary:0xff6b35,colorAccent:0x00f3ff,metalness:0.5,roughness:0.3,emissive:0.5,opacity:0.8,mode:'wireframe'},
            wide: {a:3,c:0.8,uLimit:2,twist:0.5,segments:50,thickness:1.5,rotX:0,rotY:0,rotZ:0,scale:1,colorPrimary:0xbc13fe,colorSecondary:0xff0055,colorAccent:0x00f3ff,metalness:0.95,roughness:0.05,emissive:0.1,opacity:1,mode:'solid'},
            crystal: {a:1,c:1,uLimit:3,twist:0,segments:100,thickness:1,rotX:0,rotY:0,rotZ:0,scale:1,colorPrimary:0x00f3ff,colorSecondary:0xffffff,colorAccent:0x00f3ff,metalness:1,roughness:0,emissive:0.2,opacity:0.6,mode:'solid'},
            neon: {a:1.2,c:1.5,uLimit:4,twist:1.57,segments:70,thickness:0.6,rotX:0,rotY:0,rotZ:0,scale:1,colorPrimary:0xff0055,colorSecondary:0x39ff14,colorAccent:0xff6b35,metalness:0.3,roughness:0.4,emissive:0.8,opacity:0.7,mode:'points'}
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const presetName = btn.getAttribute('data-preset');
                const preset = presets[presetName];
                if(preset){
                    Object.assign(params, preset);
                    // Update all UI controls
                    document.getElementById('radius').value = params.a;
                    document.getElementById('height').value = params.uLimit;
                    document.getElementById('curve').value = params.c;
                    document.getElementById('twist').value = params.twist;
                    document.getElementById('segments').value = params.segments;
                    document.getElementById('thickness').value = params.thickness;
                    document.getElementById('rotx').value = params.rotX;
                    document.getElementById('roty').value = params.rotY;
                    document.getElementById('rotz').value = params.rotZ;
                    document.getElementById('scale').value = params.scale;
                    document.getElementById('metalness').value = params.metalness;
                    document.getElementById('roughness').value = params.roughness;
                    document.getElementById('emissive').value = params.emissive;
                    document.getElementById('opacity').value = params.opacity;
                    document.getElementById('color-primary').value = toHexColor(params.colorPrimary);
                    document.getElementById('color-secondary').value = toHexColor(params.colorSecondary);
                    document.getElementById('color-accent').value = toHexColor(params.colorAccent);
                    
                    // Update all value displays
                    syncAllDisplays();
                    
                    // Update mode buttons
                    btns.forEach(b => document.getElementById(b).classList.remove('active'));
                    if(params.mode === 'wireframe') document.getElementById('mode-wire').classList.add('active');
                    if(params.mode === 'solid') document.getElementById('mode-solid').classList.add('active');
                    if(params.mode === 'points') document.getElementById('mode-points').classList.add('active');
                    if(params.mode === 'lines') document.getElementById('mode-lines').classList.add('active');
                    
                    // Show/hide physics control based on mode
                    const physicsControl = document.getElementById('physics-control');
                    physicsControl.style.display = params.mode === 'lines' ? 'block' : 'none';
                    
                    createHyperboloid();
                }
            });
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            document.querySelector('[data-preset="default"]').click();
        });

        document.getElementById('screenshot-btn').addEventListener('click', () => {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `hyperboloid-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
        });

        // Animation & FPS
        const clock = new THREE.Clock();
        let lastFPSUpdate = performance.now();
        let frames = 0;
        const fpsElem = document.getElementById('fps-counter');

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const t = clock.getElapsedTime();

            if (mesh && params.autoRotate) {
                mesh.rotation.y += params.animSpeed * 0.35 * delta;
            }

            // Pulsing effect (additive to base scale)
            let currentScale = params.scale;
            if(mesh && params.pulseRate > 0){
                const pulse = Math.sin(t * params.pulseRate) * 0.1;
                currentScale = params.scale * (1 + pulse);
            }
            if(mesh && mesh.scale.x !== currentScale) {
                mesh.scale.setScalar(currentScale);
            }

            // pulsierendes Licht
            pointLight1.intensity = 1.5 + Math.sin(t * 2.0) * 0.5;
            pointLight2.intensity = 1.5 + Math.cos(t * 1.6) * 0.45;
            pointLight1.color.setHex(params.colorPrimary);
            pointLight2.color.setHex(params.colorAccent);

            controls.update();
            renderer.render(scene, camera);

            // FPS update jede Sekunde
            frames++;
            const now = performance.now();
            if (now - lastFPSUpdate >= 1000) {
                const fps = Math.round((frames * 1000) / (now - lastFPSUpdate));
                fpsElem.innerText = `FPS: ${fps}`;
                frames = 0;
                lastFPSUpdate = now;
            }
        }

        window.addEventListener('resize', () => {
            const oldWidth = particleCanvas.width;
            const oldHeight = particleCanvas.height;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            // Redistribute particles proportionally to new canvas dimensions
            const scaleX = particleCanvas.width / oldWidth;
            const scaleY = particleCanvas.height / oldHeight;
            particles.forEach(p => {
                p.x *= scaleX;
                p.y *= scaleY;
            });
        });

        // Initialize all value displays to match default params
        syncAllDisplays();
        
        // Start
        animate();
    </script>
</body>
</html>
